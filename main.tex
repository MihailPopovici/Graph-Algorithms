\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Tema 1 - Algoritmica Grafurilor}

\author{Mihail Popovici, Luca Petrovici, Alexandru-Constantin Iov, George-Razvan Rusu}
\begin{document}
\maketitle

\section*{\fontsize{20}{50}\selectfont Problema 1}
{\fontsize{14}{16}\selectfont  Un graf eulerian este un graf în care există un parcurs închis care trece prin toate muchiile sale. Deoarece graful G = (V,E) este conex și toate nodurile sale au gradul par, acesta este un graf eulerian. 
\par O metodă de a înlocui fiecare muchie a lui G cu exact un arc astfel încât în noul digraf G' fiecare nod să aibă gradul interior egal cu cel exterior este de a trece prin parcurs. Prin schimbarea, înspre sensul de mers, a fiecărei muchii cu un arc, de fiecare dată când trecem printr-un nod îi vom crește atât gradul interior cât și cel exterior cu 1. Singura excepție este primul nod din parcurs, al cărui grad exterior vă fi incrementat cu 1 la începutul parcurgerii, rămânând diferit de cel interior până la finalizarea parcurgerii, când vor fi egalate.}

\section*{\fontsize{20}{50}\selectfont Problema 2}
\subsection*{\fontsize{16}{30}\selectfont Subpunctul a}
{\fontsize{14}{16}\selectfont  Presupunem prin reducere la absurd ca xy $\in$  E $\backslash$ E' și x nu este strămoș al lui y sau invers. 
\par Din aceasta, rezultă că x și y au un strămoș comun în arborele generat de parcurgerea DFS. Dacă x și y au strămoș comun în arborele DFS înseamnă că parcurgerea a trecut prin x și a rămas fară noduri de explorat. Apoi, acesta s-a întors înapoi la strămoșul comun și a continuat parcurgerea din acesta, urmând să treacă prin y. 
\par Însă, pentru ca DFS-ul să ajungă înapoi la strămoșul comun, atunci ar trebui ca x să nu mai aibă niciun vecin neexplorat, dar deoarece xy $\in$ E, algoritmul nu ar mai fi ajuns la acel strămoș comun, plasandu-l pe y ca fiul lui x , adica x este strămoșul lui y .
\par Deoarece am ajuns la contradicție, înseamnă că presupunerea este falsă, deci dacă xy $\in$ E $\backslash$ E', x este un ascendent al lui y sau invers. }
\subsection*{\fontsize{16}{30}\selectfont Subpunctul b}
{\fontsize{14}{16}\selectfont
Presupunem prin reducere la absurd ca $\exists$ u a.i. $up_d$(u) $>$ level(u). 
\par Asa cum am demonstrat la subpunctul a, daca 2 noduri sunt vecine in graful initial, atunci unul dintre ele va fi stramosul celuilalt, adica va avea nivelul mai mic ca celalalt.  In cel mai rau caz, upd(u) va fi format din toti stramosii lui u, adica uv $\in$ E $\backslash$ E', $\forall$ v $\in$ $N_g$(u). In acest caz, upd(u) = level(u), ceea ce inseamna ca upd(u) nu poate fi mai mare decat level(u), deci presupunerea este eronata.
\par Rezulta ca upd(u) $\le$ level(u), $\forall$ u $\in$ V. }
\subsection*{\fontsize{16}{30}\selectfont Subpunctul c}
{\fontsize{14}{16}\selectfont
$\forall$ xy $\in$ E, aceasta va contribui fie la $up_d$(x), fie la $up_d$(y).
\par Muchia nu poate contribui la ambele in acelasi timp, deoarece ar implica level(x) $<$ level(y) si level(y) $<$ level(x) simultan, ceea ce nu este posibil. 
\par In acelasi timp, muchia xy nu poate sa nu incrementeze niciun $up_d$(), deoarece ar trebui ca level(x) $<$ level(y) si level(y) $<$ level(x) sa fie false in acelasi timp, deci, level(x) $\ge$ level(y) si level(y) $\ge$ level(x) in acelasi timp, adica level(x) = level(y), ceea ce este imposibil deoarece muchia xy $\in$ E, rezulta fie x este stramosul lui y, fie y este stramosul lui x (conform subpunctului a).
\par Asadar, fiecare muchie contribuie la suma de $up_d$() cu 1, adica in final $\sum_{u \in V} {up}_d(u)$
 = m.
}
\subsection*{\fontsize{16}{30}\selectfont Subpunctul d}
{\fontsize{14}{16}\selectfont
Asa cum am demonstrat la b, upd(u) $\le$ level(u), \\ $\forall$ u $\in$ V. Insumand inegalitatea pentru fiecare u, vom obtine:  \\
 \centerline {$\sum_{u \in V} {up}_d(u)$ $\le$ $\sum_{u \in V} {level(u)}$ } \\
 \par Conform subpunctului c, $\sum_{u \in V} {up}_d(u)$ = m $\Rightarrow$ \\ m $\le$ $\sum_{u \in V} {level(u)}$ , dar $\sum_{u \in V} {level(u)}$ $\le$ n*level(x), unde x este nodul cu cel mai mare level, adica nodul care da adancimea arborelui DFS. $\Leftrightarrow$ m $\le$ n * level(x) $\Rightarrow$ m/n $\le$ level(s) $\Rightarrow$ adancimea lui T este cel putin m/n; 
}
\subsection*{\fontsize{16}{30}\selectfont Subpunctul e}
{\fontsize{14}{16}\selectfont
Insert contra exemplu aici, cel de pe foaie. 
Deoarece \\ $\lbrace$ $C_{xy}$ : xy $\in$ E $\backslash$ E' $\rbrace$ nu contine toate circuitele din G, atunci nu vom fi niciodata siguri ca circuitul de lungime minima se poate afla prin prelucrarea unei traversari DFS a lui G.  
}
\end{document}
